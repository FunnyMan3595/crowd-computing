{% extends "basic.html" %}
{% block page_title %}{% if show %}{{ show.display_name|default:show.name }} by {{ show.host.twitch_username }}{% endif %}{% endblock %}
{% block page_name %}{% if show %}{{ show.display_name|default:show.name }} by {{ show.host.twitch_username }}{% endif %}{% endblock %}
{% block content %}
{% if me == host %}
This is your show, <a href='manage'>click here</a> for the management interface.<br/>
<br/>
{% endif %}
<h3 class="collapser" onclick="collapse(this)">Minimap</h3>
<div class="collapsed" id="minimap_holder">
<canvas width=400 height=400 id="minimap"></canvas>
</div>
<script>
let minimap = document.getElementById("minimap");
let ctx = minimap.getContext("2d");
let images = {};
let minimap_holder = document.getElementById("minimap_holder");
let update_interval = null;
let last_etag = null;
let crowd_sources = [];
let initialized = false;
let scroller = null;
let scroller_origin_x = null;
let scroller_origin_z = null;

function render(left, top, zoom) {
  console.log([left, top, zoom]);
  const load_image = (crowd_source) => {
    return new Promise((resolve, reject) => {
      if (crowd_source.image === undefined) {
        crowd_source.image = new Image();
        let url = "minimaps/" + crowd_source.x + "/" + crowd_source.y + "/" + crowd_source.z;
        fetch(url).then(() => {
          crowd_source.image.onload = () => resolve(crowd_source);
          crowd_source.image.onerror = reject;
          crowd_source.image.src = url;
        });
      } else {
        crowd_source.image.onload = () => resolve(crowd_source);
        crowd_source.image.onerror = reject;
        if (crowd_source.image.complete) {
          if (crowd_source.image.height > 0) {
            resolve(crowd_source);
          } else {
            reject();
          }
        }
      }
    })
  }

  let prerender = new OffscreenCanvas(minimap.width, minimap.height);
  let pre_ctx = prerender.getContext("2d");

  Promise.all(crowd_sources.map(load_image)).then(loaded_crowd_sources => {
    pre_ctx.setTransform();
    pre_ctx.imageSmoothingEnabled = false;
    pre_ctx.translate(-left, -top);
    pre_ctx.scale(zoom, zoom);
    for (let crowd_source of loaded_crowd_sources) {
      pre_ctx.drawImage(crowd_source.image, crowd_source.x-crowd_source.range - scroller_origin_x, crowd_source.z-crowd_source.range - scroller_origin_z, crowd_source.range*2+1, crowd_source.range*2+1);
    }

    ctx.clearRect(0, 0, minimap.width, minimap.height);
    ctx.drawImage(prerender, 0, 0);
    console.log(loaded_crowd_sources.length);
  }).catch(() => {
    setTimeout(() => render(left, top, zoom), 1);
  });
}

if ('ontouchstart' in window) {
  minimap.ontouchstart = (e) => {
    scroller.doTouchStart(e.touches, e.timeStamp);
    return false;
  }

  minimap.ontouchmove = (e) => {
    scroller.doTouchMove(e.touches, e.timeStamp, e.scale);
    return false;
  }

  minimap.ontouchend = (e) => {
    scroller.doTouchEnd(e.timeStamp);
    return false;
  }

  minimap.ontouchcancel = (e) => {
    scroller.doTouchEnd(e.timeStamp);
    return false;
  }
} else {
  let mouse_down = false;

  minimap.onmousedown = (e) => {
    scroller.doTouchStart([{
      pageX: e.pageX,
      pageY: e.pageY,
    }], e.timeStamp);
    mouse_down = true;
    return false;
  }

  minimap.onmousemove = (e) => {
    if (!mouse_down) {
      return true;
    }

    scroller.doTouchMove([{
      pageX: e.pageX,
      pageY: e.pageY,
    }], e.timeStamp);
    return false;
  }

  minimap.onmouseup = (e) => {
    scroller.doTouchEnd(e.timeStamp);
    return false;
  }

  minimap.onwheel = function(e) {
    let rect = minimap.getBoundingClientRect();
    scroller.setPosition(rect.left, rect.top);
    scroller.doMouseZoom(-e.wheelDelta, e.timeStamp, e.pageX, e.pageY);
    return false;
  }
}

async function update_minimap() {
  let headers = {};
  if (last_etag !== null) {
    headers["If-None-Match"] = '"' + last_etag + '"';
  }
  const response = await fetch("minimaps/metadata", { headers: headers });
  if (response.status == 304) {
    return;
  }
  if (response.status != 200) {
    console.log("Minimap refresh failed: ", response);
    return;
  }

  let parsed = await response.json();
  last_etag = parsed["etag"];
  crowd_sources = parsed["crowd_sources"];
  if (crowd_sources.length == 0) {
    return;
  }

  let overall_x_min = crowd_sources[0].x - crowd_sources[0].range;
  let overall_z_min = crowd_sources[0].z - crowd_sources[0].range;
  let overall_x_max = crowd_sources[0].x + crowd_sources[0].range;
  let overall_z_max = crowd_sources[0].z + crowd_sources[0].range;

  for (let crowd_source of crowd_sources) {
    let x_min = crowd_source.x - crowd_source.range;
    if (overall_x_min > x_min) {
      overall_x_min = x_min;
    }
    let z_min = crowd_source.z - crowd_source.range;
    if (overall_z_min > z_min) {
      overall_z_min = z_min;
    }
    let x_max = crowd_source.x + crowd_source.range;
    if (overall_x_max < x_max) {
      overall_x_max = x_max;
    }
    let z_max = crowd_source.z + crowd_source.range;
    if (overall_z_max < z_max) {
      overall_z_max = z_max;
    }
  }

  let old_scroller_origin_x = scroller_origin_x;
  scroller_origin_x = overall_x_min;
  let zoom_x_scale = minimap.width / (overall_x_max - overall_x_min + 1);
  let old_scroller_origin_z = scroller_origin_z;
  scroller_origin_z = overall_z_min;
  let zoom_z_scale = minimap.height / (overall_z_max - overall_z_min + 1);
  let zoom_scale = Math.min(zoom_x_scale, zoom_z_scale);

  if (scroller === null) {
    scroller = new Packed.Scroller(render, {
      zooming: true,
      locking: false,
      minZoom: zoom_scale,
      maxZoom: Math.max(minimap.width, minimap.height),
    });
    scroller.setDimensions(minimap.width, minimap.height, overall_x_max - overall_x_min + 1, overall_z_max - overall_z_min + 1);
    scroller.zoomTo(zoom_scale)
  } else {
    scroller.options.minZoom = zoom_scale;
    scroller.options.maxZoom = Math.max(minimap.width, minimap.height);
    scroller.setDimensions(minimap.width, minimap.height, overall_x_max - overall_x_min + 1, overall_z_max - overall_z_min + 1);
    let rect = minimap.getBoundingClientRect();
    scroller.scrollBy((old_scroller_origin_x - scroller_origin_x) * scroller.__zoomLevel, (old_scroller_origin_z - scroller_origin_z) * scroller.__zoomLevel, false);
    scroller.zoomBy(1, false, rect.left, rect.top);
  }
}

function mutation_callback(mutations, observer) {
  for (const mutation of mutations) {
    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
      if (minimap_holder.classList.contains("open")) {
        if (update_interval === null) {
          update_interval = setInterval(update_minimap, 1000);
        }
      } else {
        if (update_interval !== null) {
          clearInterval(update_interval);
          update_interval = null;
        }
      }
    }
  }
}
let observer = new MutationObserver(mutation_callback);
observer.observe(minimap_holder, { attributes: true });

function bind_button(id) {
  let button = document.getElementById(id + "_button");
  let text = document.getElementById(id + "_text");
  let region_modal = document.getElementById("region_modal");

  button.onclick = () => {
    region_modal.region_id = id;
    modal(region_modal);
    return false;
  }
}

function finish_pick_region(region) {
  let region_modal = document.getElementById("region_modal");
  let id = region_modal.region_id;
  let text = document.getElementById(id + "_text");
  let hidden = document.getElementById(id);
  unmodal();
  text.innerText = region;
  hidden.value = region;
}

document.body.onload = () => {
  bind_button("miniconfig_source");
  bind_button("miniconfig_target");
{% if miniconfigs %}
  bind_button("edit_mc_source");
  bind_button("edit_mc_target");
{% endif %}
}

function open_edit_mc_form(elem, name, source, target, limit) {
  document.getElementById('edit_mc_old_name').value = name;
  document.getElementById('edit_mc_name').value = name;
  document.getElementById('edit_mc_source').value = source;
  document.getElementById('edit_mc_source_text').innerText = source;
  document.getElementById('edit_mc_target').value = target;
  document.getElementById('edit_mc_target_text').innerText = target;
  document.getElementById('edit_mc_limit').value = limit;

  let form=document.getElementById('edit_mc_form');
  elem.after(form);
  form.classList.remove('hidden');
}
</script>
{% if miniconfigs %}
<h3 class="collapser" onclick="collapse(this)">Your Mini Configs</h3>
<div class="collapsed">
{% for mc in miniconfigs %}
<div class="group">
<b>{{ mc.name }}</b><br/>
source: {{ mc.source }}<br/>
target: {{mc.target }}<br/>
limit: {{mc.limit }}<br/>
<button onclick="open_edit_mc_form(this, '{{ mc.name }}', '{{ mc.source }}', '{{mc.target }}', '{{mc.limit }}'); return false">Edit</button>
</div>
<br/>
{% endfor %}
<form action="edit_mc" method="post" class="hidden" id="edit_mc_form" style="margin-top: 5px">
  {% csrf_token %}
  <input type="hidden" name="edit_mc_old_name" id="edit_mc_old_name">
  <table>
  {{ edit_mc_form }}
  <tr><th></th><td><input type="submit" value="Modify Config">
                   <input type="submit" name="delete" value="Delete Config">
                   <input type="button" value="Cancel" id="edit_mc_cancel" onclick="document.getElementById('edit_mc_form').classList.add('hidden'); return false"></td></tr>
  </table>
</form>
</div>
{% endif %}
<h3 class="collapser" onclick="collapse(this)">Add a new Mini Config</h3>
<div class="collapsed">
<form action="create_mc" method="post">
  {% csrf_token %}
  <table>
  {{ mc_form }}
  <tr><th></th><td><input type="submit" value="Create Config"></td></tr>
  </table>
</form>
</div>
<div class="modal hidden" id="region_modal" style="min-width: 50%; padding: 5px 10px 5px 10px">
<table id="region-list">
    <thead>
        <tr>
            <th>Name</th>
            <th>Start X</th>
            <th>Start Y</th>
            <th>Start Z</th>
            <th>End X</th>
            <th>End Y</th>
            <th>End Z</th>
            <th>Size X</th>
            <th>Size Y</th>
            <th>Size Z</th>
            <th>Total Blocks</th>
            <th>Tags</th>
        </tr>
    </thead>
</table>
<script>
  let table = document.getElementById("region-list");
  let dt = new DataTable(table, {
    dom: "Bfrtip",
    buttons: [
      'colvis',
      {
        text: 'Reload',
        action: function ( e, dt, node, config ) {
          dt.ajax.reload();
        }
      }
    ],
    columnDefs: [
      {targets: [10], visible: true, searchable: false, sortable: false},
      {targets: [0,11], visible: true, searchable: true, sortable: true},
      {targets: '_all', visible:false, searchable: false, sortable: false}
    ],
    sAjaxSource: "fetch_regions",
    serverSide: true,
  });
  table.style = "width: 100%";
  table.onclick = (e) => {
    let row = e.target?._DT_CellIndex?.row;
    if (row === undefined) {
      return;
    }
    let data = dt.rows(row).data()[0];
    finish_pick_region(data[0]);
  };
</script>
</div>
{% endblock %}
